\section{Writing Crypt$\epsilon$ Programs}\label{program}
In this section we illustrate via examples how the aforementioned primitives can be composed into a Crypt $\epsilon$ program to answer data queries.
Crypt$\epsilon$ programs can be classified into three classes based on the number and type of interaction required between the \textsf{AS} and the \textsf{CSP}.
\paragraph{\textbf{Single Decrypt Interaction Programs}}
Recall that the output of all the transformation primitives are encrypted.  Since  the \textsf{CSP} has exclusive access to the secret key, it is the only entity in the Crypt$\epsilon$ setting capable of decryption. Thus for releasing any result (albeit noisy) in the clear, we need to interact at least once with the \textsf{CSP} so that it can decrypt the encrypted noisy answer. Crypt$\epsilon$ supports this type of interactions via the two measurement primitives. Some Crypt$\epsilon$ programs require only this one round of interaction at the very end to release the noisy output. All other transformations can be performed by the \textsf{AS} via homomorphic operations on the encrypted data records. Typically these programs are counting queries on a single attribute or noisy max on a single attribute. 
Consider a database scheme $\{Age, Gender, NativeCountry, Department, Salary\}$ %such that \begin{itemize}\item $dom(Age)=\{1,\ldots,100+\}$  \item $dom(Gender)=\{Male, Female, Other\}$\item $dom(NativeCountry)=\{US,Spain,India\}$ \item $dom(Department)=\{A/C \& Finance, R\&D, Production,$\\$ Marketing,$ $HRM, Purchasing \}$ \item $dom(Salary)=\{100K,150K,...,500K\}$ \end{itemize} 
\begin{exmp}
\textit{Query: } Count the number of records satisfying $Age \in [50,60]$\\
\textbf{Crypt$\epsilon$ Program:}
Let $\phi=(Age=50 \vee Age=51 \vee ... \vee Age=60)$ \end{exmp} $\lap_{\epsilon,1}(\countagg(\filter_{\phi}(\project_{Age}(\encD))))$
%\begin{enumerate} \item $\mathbf{\tilde{T}}_1$=\textsf{Project}($\boldsymbol{\tilde{\mathcal{D}}}$, $Age$)  \item  $\mathbf{T_2}$ = \textsf{Filter}($\mathbf{\tilde{T}}_1,\phi$)\item $\mathbf{C}$ = \textsf{Count}($\mathbf{T_2}$) \item $\hat{C}$=\textsf{Laplace}($\mathbf{C},\epsilon)$\end{enumerate}
\begin{exmp}\textit{Query: } Return the 5 most frequent age values.\\\textbf{Crypt$\epsilon$ Program:}\end{exmp}
$\noisymax^5_{\epsilon,1}(\groupbystar_{Age}(\encD))$%\begin{enumerate} \item $\mathbf{C}$=\textsf{GroupBy*}($\boldsymbol{\tilde{\mathcal{D}}},Age$)   \item $\tilde{C}$=\textsf{NoisyMax}($\mathbf{C},5,\epsilon)$\end{enumerate}
\begin{exmp}\textit{Query: } Return the marginal over attributes Age and Gender values.\\\textbf{Crypt$\epsilon$ Program:}\end{exmp}
$\lap_{\epsilon,1}(\groupbystar_{Age\times Gender}(\project_{Age \times Gender}(\crossproduct_{Age,Gender}(\encD))))$%\begin{enumerate} \item $\tilde{\mathbf{T_1}}$=\textsf{CrossProduct}$(\boldsymbol{\tilde{\mathcal{D}}},Age,Gender)$ \item $\tilde{\mathbf{T_2}}$=\textsf{Project}$(\tilde{\mathbf{T_1}}, Age \times Gender)$\item  $\mathbf{C}$=\textsf{GroupBy*}($\tilde{\mathbf{T_2}},Age \times Gender $)   \item $\hat{C}$=\textsf{Laplace}($\mathbf{C},\epsilon)$\end{enumerate}

\paragraph{\textbf{LabHE Multiplication Interaction Programs}}
Recall that labeled homomorphic encryption allows multiplication of two ciphers. Generalization to a $n$-multiplicand, $n > 2$ case can be done according to the protocol described in section 4.2. However it requires intermediate interactions with the \textsf{CSP}. Thus all Crypt$\epsilon$ programs that require multiplication of more than two ciphers need interaction with the \textsf{CSP}. 
All programs with more than three attributes in its boolean predicate would thus fall under this class.
\begin{exmp}\textit{Query:} Return the marginal over Age and Gender where NativeCountry is Mexico. \\\textbf{Crypt$\epsilon$ Program:}\\ Let $\phi$ be the condition that $(NativeCountry==Mexico) $ \begin{multline*}\lap_{\epsilon,1}(\groupbystar_{Age\times Gender}(\filter_{\phi}(\project_{Age\times Gender, NativeCountry}\\(\crossproduct_{Age,Gender}(\encD)))))\end{multline*}\end{exmp}% \begin{enumerate}\item $\tilde{\mathbf{T_1}}$=\textsf{CrossProduct} ($\boldsymbol{\tilde{\mathcal{D}}},Age,Gender$) \item $\tilde{\mathbf{T_2}}$=\textsf{Project}$(\tilde{\mathbf{T_1}}, Age \times Gender, NativeCountry)$ \item $\mathbf{T_3}$=\textsf{Filter}($\tilde{\mathbf{T_2}},\phi$)\item $\mathbf{C}$=\textsf{GroupBy*}($\tilde{\mathbf{T_2}},Age\times Gender$)\item $\hat{C}$=\textsf{Laplace}$(\mathbf{C},\epsilon)$ \end{enumerate}
\begin{exmp} \textit{Query:} Count the number of for male employees of US having age =50. \\\textbf{Crypt$\epsilon$ Program} \\Assume $\phi=(Age=30 \wedge Gender=Male \wedge NativeCountry=Mexico)$ \end{exmp} $\lap_{\epsilon,1}(\countagg(\filter_{\phi}(\project_{Age,Gender,NtiveCountry}(\encD))))$
%\begin{enumerate} \item $\mathbf{\tilde{T}}_1$=\textsf{Project}($\boldsymbol{\tilde{\mathcal{D}}}$, $Age,Gender,NativeCountry$)  \item  $\mathbf{T_2}$ = \textsf{Filter}($\mathbf{\tilde{T}}_1,\phi$)\item $\mathbf{C}$ = \textsf{Count}($\mathbf{T_2}$) \item $\tilde{C}$=\textsf{Laplace}($\mathbf{C},\epsilon)$\end{enumerate}
\paragraph{\textbf{Other Interaction Programs}}
Recall that the \textsf{GroupBy} primitive requires an intermediate interaction with the \textsf{CSP} (for generating the encrypted one-hot-coding). The \textsf{CountDistinct} primitive also uses a Yao's garbled circuit and hence requires a round of interaction. This in addition to the interaction required for decrypting the noisy answer (as explained above). Thus any program with the \textsf{GroupBy} or \textsf{CountDistinct} primitive requires two rounds of interaction in the least. 
\begin{exmp}\textit{Query:} Return the number of distinct age values for the male employees in the database. \\ \textbf{Crypt$\epsilon$ Program:} \\Let  $\phi=(Gender=Male)$ be the predicate such that age counts are in $\{1,...,m\}$\end{exmp} $\lap_{\epsilon,1}(\countdistinct(\groupbystar_{Age}(\filter_{\phi}(\project_{Age \times Gender}(\encD)))))$ %\begin{enumerate}\item $\mathbf{\tilde{T}}_1$=\textsf{Project}($\boldsymbol{\tilde{\mathcal{D}}}$, $Age,Gender$) \item $\mathbf{T}_2$=\textsf{Filter}($\mathbf{\tilde{T}}_1,\phi$) \item $\mathbf{T_3}$=\textsf{GroupBy*}($\mathbf{\tilde{T}}_1,Age$)\item $\mathbf{C}$=\textsf{CountDistinct}$(\mathbf{T_3})$\item $\hat{C}$=\textsf{Laplace}($\mathbf{C},\epsilon$)\end{enumerate} 
\begin{exmp}\textit{Query: } Return the number of  age values having at least 10 records in the database. \\ \textbf{Crypt$\epsilon$ Program}:\\ Let $\phi_G$ be the predicate such that age count is in $\{10,...,m\}$. \end{exmp}
$\lap_{\epsilon,1}(\countagg(\filter_{\phi}(\groupby_{Age}(\project_{Age}(\encD)))))$
%\begin{enumerate}\item $\mathbf{\tilde{T}}_1$=\textsf{Project}($\boldsymbol{\tilde{\mathcal{D}}}$, $Age$) \item $\mathbf{\tilde{T_2}}$=\textsf{GroupBy}($\mathbf{\tilde{T}}_1,Age$)\item $\mathbf{T_3}$=\textsf{Filter}$(\mathbf{\tilde{T_2}},\phi_G)$\item $\mathbf{C}$=\textsf{Count}($\mathbf{T_3}$)\item $\hat{C}$=\textsf{Laplace}$(\mathbf{C},\epsilon,)$\end{enumerate}