
\begin{table}[t]
\small
\centering
\caption {Notations}
 \begin{tabular}{l|l}  \toprule
 \multicolumn{1}{c}{\textbf{Symbol} } &  \multicolumn{1}{c}{\textbf{Meaning}}\\\midrule
\textbf{Boldface}& \text{- represents encrypted data}\\
$\tilde{}$ & \text{- represents one-hot-coding}  \\  $\hat{}$ & -represents a differentially private output  \\ $A$ &- an attribute  \\ $s_A$ &- size of domian of attribute $A$
\\$dom(A)=\{v_1,\ldots,v_{s_A}\}$ & - domain of attribute $A$\\ $ct_{A,i}$  &- \# \text{records with value $v_i$ for attribute} A\\ $m$   &-\text{\# number of data onwers}\\ $\boldsymbol{\tilde{\mathcal{D}}}$  &- \text{encrypted database with records in}\\&\text{  per-attribute one-hot-coding } \\ $\mathcal{A}=\{\mathcal{A}_1,...\mathcal{A}_l\}$   &- \text{set of attributes in the schema of $\boldsymbol{\tilde{\mathcal{D}}}$}\\
$x \times y \text{ table } \mathbf{T}$   &- \text{an encrypted table  with $x$ records in}\\&\text{ one-hot-coding and $y$ columns one for}\\&\text{ each attribute; serves as one of the }\\&\text{ inputs to a transformation primitive}\\ $\mathbf{B}$&- \text{A $m$ - lengthed vector such that each entry}\\&\text{ $\textbf{B}[i]$ represents whether record $r_i, i \in [m]$}\\& \text{is relevant to the program at hand} \\ $V$ & -\text{represents a vector}\\$C$ &- \text{represents a scalar}\\$P$ & - \text{represents a set}\\
 \bottomrule
 \end{tabular}
\end{table}

%$Attribute(\phi)$ - The set of attributes that appear in the boolean condition $\phi$\\
%$\mathcal{I}(A)$- Denotes the integral representation of $dom(A)$\\$\mathcal{I}_A(\phi)$- Denotes the elements in $\mathcal{A}$ that satisfies $\phi$


\section{System Overview}

\begin{figure}\includegraphics[height=5cm,width=8cm]{cry.png} \caption{ Crypt$\epsilon$ System Setting: The  \textsf{AS} runs the Crypt$\epsilon$ programs. The \textsf{CSP} manages the cryptographic primitves. } \end{figure}

%\subsection{Notations}


This section provides an overview of \system.

%\subsection{Crypt$\epsilon$ Components}
\system comprises of the following parties\begin{enumerate}
\item \textbf{Data-Owners (\textsf{DO})}-  Each data-owner $\textsf{DO}_i, i \in [m]$ has  a
private data record $D_i$ and is willing to share it only if encrypted.    \item \textbf{Analytics Server (\textsf{AS})} - The \textsf{AS} wants to run a set of differentially private programs on the dataset $D$ obtained by merging the local data records $D_1, ... , D_m$, but has
access only to the encrypted copies of them.
\item \textbf{Cryptographic Service Provider (\textsf{CSP})} -
 The \textsf{CSP} manages the cryptographic primitives used in Crypt$\epsilon$ and interacts with the \textsf{AS} to compute the
noisy answers.
\end{enumerate}
%\xh{Rather than providing all the encryption details, can we just simply have an algorithm box to summarize the interactions between these three components. Then describe the interactions and highlight the key functionalities of each component, and then the trust model. }

\subsection{Crypt$\epsilon$ Modules}

\stitle{Cryptographic Service Provider.}

\textbf{1. \textit{ Cryptographic Key Manager}-} The foremost duty of the \textsf{CSP} is to initialize the encryption scheme of Crypt$\epsilon$. This task is handled by the \textit{Cryptographic Key Manager} module which generates the key pair $(sk,pk)$ for the \textsf{labHE} scheme. It stores the secret key, $sk$ with itself and releases the public key, $pk$. Note that since only the \textsf{CSP} has access to the secret key $sk$, it is the only entity capable of decryption in Crypt$\epsilon$.

\textbf{2. \textit{ Data Decryption} - } The \textsf{CSP} being the only entity capable of decryption,  any measurement of the data (even noisy) has to involve the \textsf{CSP} in the loop. The \textit{Data Decryption} module is tasked with handling all such interactions with the \textsf{AS}. 

\textbf{3. \textit{ Privacy Engine}-} Crypt$\epsilon$ starts of with a total privacy budget of $\epsilon^*$ which is unanimously agreed upon by all the data owners. Note that the mechanism of deciding $\epsilon^*$ should be piloted by social prerogatives and is currently outside the scope of Crypt$\epsilon$. Recall that the CSP is the only entity capable of decryption in Crypt$\epsilon$, hence any measurement of the data (even noisy) has to involve the \textsf{CSP} in the loop.  Thus for executing every program, the \textsf{AS} has to interact with the \textsf{CSP} at least once thereby giving the \textsf{CSP} the opportunity to monitor the \textsf{AS}'s actions in terms of privacy budget expenditure. The \textit{Privacy Engine} module hence maintains a public ledger that records the privacy budget spent in executing every individual program. Once the privacy cost incurred reaches the capped limit of $\epsilon^*$, the \textsf{CSP} refuses to decrypt any further answers thereby ensuring that the privacy budget is not overspend.  The ledger is completely public allowing any data owner to verify it as and when desired.
\subsection*{\textit{Data Owners}}
\textbf{1. \textit{Data Encoder}}-  Each data owner $\textsf{DO}_i, i \in [m]$ has a private data record $D_i$ of the form $\langle \mathcal{A}_1,...\mathcal{A}_l\rangle$ where $\mathcal{A}_j$ is an attribute. At the very outset, every data owner  $\textsf{DO}_i$ represents his/her private record $D_i$ in its respective per attribute one-hot-coding format. The one-hot-coding is a way of representation for categorical attributes and is described as follows. First the data is converted to an integral representation in the following way. Let us assume that the total number of categories is $k$, then each category is represented by an unique integer in $\{1,..., k\}$. Now the one-hot-encoding for a category $x$ with integral representation $t , t \in [k]$ is given by a $k$-lengthed vector $\tilde{x}$ such that $\tilde{x}[t]=1, \forall i \in [k], i\neq t, \tilde{x}[i]=0$. 
For example consider an attribute $Age$ with domain $\{1,...,100\}$. In this case since the categories itself are integral, we can skip the first step. Thus the one-hot-encoding corresponding to a value $x=30, type(x)=Age$ is given by $\tilde{x}[30]=1, \tilde{x}[i]=0, i \in [100], i \neq 30 $. \begin{comment}In fact the one-hot-coding can be generalized to represent data across $n$ different attributes. For example, in addition to the aforementioned $Age$ attribute consider  another attribute  $Gender$ with domain $\{Male, Female, Other\}$. Let the categorical values $\textit{Male, Female }$ and $Other$ be represented by integers $1, 2$ and $3$ respectively. Thus a one-hot-encoding for a value $X=\langle1,30\rangle \in Age \times Gender$ is given by \begin{gather*}i \in [300] \\\tilde{X}[i]=\begin{cases}1, \textit{ if } i =30,\\ 0 , \textit{ otherwise }\end{cases}\end{gather*}
\end{comment}
Thus for each data owner in Crypt$\epsilon$, if for example  the database schema is given by  $\langle Age,Gender\rangle$ then a data owner with the record $\langle 30, Male\rangle$ would firstly represent it as $\mathcal{E}(D)=\langle[\underbrace{0,\ldots,0}_{29},1,\underbrace{0,\ldots,0}_{70}],[1,0]\rangle$. \\
\textbf{2. \textit{Data Encryption}} - The \textit{Data Encryption} module stores the public key $pk$ of the labHE scheme used in Crypt$\epsilon$ which is announced by the CSP. This key is used for an element-wise encryption of the data owners encoded record of per attribute one-hot-codings. In our aforementioned example, we get \begin{gather*}\mathbf{D}=<[\underbrace{labEnc_{pk}(0),\ldots}_{29},labEnc_{pk}(1),\underbrace{\ldots,labEnc_{pk}(0)}_{70}]>\\,
<[labEnc_{pk}(1),labEnc_{pk}(0)]>\end{gather*}. Finally the data owner sends this encrypted record to the AS via a secure channel. Note that this is the only interaction that a data owner ever participates in. All the query answering are carried out by the \textsf{AS} and the \textsf{CSP} with the data owners being completely off line.
\subsection*{\textit{Analytics Server}}

\textbf{1.\textit{ Aggregator}}- The \textit{Aggregator} collects the encrypted records $\mathbf{\tilde{D_i}}$ from each of the data owners $\textsf{DO}_i$ and collates them into a single encrypted database $\boldsymbol{\tilde{\mathcal{D}}}$. Note that in contrast, the server in the \textsf{CDP} model, being trusted, stores the data in the clear whereas in the \textsf{LDP} model the untrusted server stores appropriately randomized (noisy) data.    \\\textbf{2.\textit{ Program Executor}}- The \textit{Program Executor} is the most important module of the \textsf{AS} and is tasked with the execution of Crypt$\epsilon$ programs. It takes as input a Crypt$\epsilon$ program from an external analyst, alongside the appropriate privacy parameter $\epsilon$ and releases the differentially private output computed in cohorts with the CSP. Crypt$\epsilon$ supports 9 different primitives on the encrypted data and a Crypt$\epsilon$ program is an execution plan expressed as a sequence of these Crypt$\epsilon$ primitives. The primitives can be broadly classified into two types- transformation primitives and measurement primitives. Transformation primitives allow certain transfigurations on the encrypted data and are performed almost entirely by the \textsf{AS}. The measurement primitives on the other hand reveal some noisy measurement on the data and requires interaction with the \textsf{CSP}. A typical Crypt$\epsilon$ program execution consists of  a series of transformation on the encrypted data followed by a measurement primitive involving the \textsf{CSP} to decrypt the noisy answer. Both the \textsf{AS} and the \textsf{CSP} partake in the computation of the random noise to be added to the program output. This two-fold noise addition is necessary because  had only one of them added the noise, then after the release of the differentially private output, that party can simply subtract out the noise to reveal the true private answer. Since in Crypt$\epsilon$ the point of noise addition is just at the two servers, unlike at every individual in \textsf{LDP}, we are able to get constant error accuracy guarantees just like in \textsf{CDP}. 
\subsection{Crypt$\epsilon$ at work}
The complete workflow of Crypt$\epsilon$ is outlined as follows\\1) \textbf{\textsf{Setup Phase}} - This is the very first step in Crypt$\epsilon$ where the key manager of \textsf{CSP} generates the key pair for labHE $(sk,pk)$, publishes $pk$ and stores $sk$. \\2) \textbf{\textsf{Data Collection Phase}}- In the next phase, the $\textit{Data 
Encoder}$ and $\textit{Data Encryption}$ modules of every data owner, work to produce the encrypted data records which are then submitted to the \textsf{AS}. The data owners are relieved of all other duties in the Crypt$\epsilon$ setting and can go completely off-line. The $\textit{Aggregator}$ module of the \textsf{AS} then aggregates these encrypted records into a single encrypted database $\boldsymbol{\tilde{\mathcal{D}}}$. \\3) \textbf{\textsf{ Program Execution Phase}} - In this phase, the \textsf{AS} executes a Crypt$\epsilon$ program with some interactions with the \textsf{CSP}  and generates a differentially private output.  \\
Note that the \textsf{Setup} and \textsf{Data Collection} phases occur just once at the very beginning, every subsequent program  is handled via the corresponding  \textsf{Program Execution} phase.
\subsection{Trust Model}
Both the servers, \textsf{AS} and \textsf{CSP} are completely untrusted in Crypt$\epsilon$. 
Thus from the data owners perspective the trust assumption is similar to that of the local differential privacy model; the data owners need not place their trust in any external entity. 
However there are two differences in the Crypt$\epsilon$ setting from the local differential privacy model.

 \textbf{Firstly}, we assume that the \textsf{AS} and the \textsf{CSP} do not collude with each other and follow the honest-but-curious (a.k.a semi-honest) adversary model. That is, they always follow the instructions of the protocol unerringly but strive to learn extra information about the private records from the messages received during the execution of the protocol (i.e., passive security). Moreover we assume that each data owner involved has a private and authenticated channel with the \textsf{AS}. This is to prevent any third party (including the \textsf{CSP}) from eavesdropping. 
 
 \textbf{Secondly}, the adversary (specifically the two servers \textsf{AS} and the \textsf{CSP}) is now reduced to a computationally bounded one as opposed to the information theoretic unbounded adversary in the general differential privacy setting.\\
Note that the first trust assumption could be relaxed if we expunge the \textsf{CSP} from Crypt$\epsilon$ setting and instead engage the $m$ data owners and the \textsf{AS} in a $m+1$ secure computation protocol. However as the number of data owners grow, the communication and computation overheads of this $m+1$ secure computation protocol would get prohibitively high. Thus by introducing a separate entity in the form of the \textsf{CSP}, we factor out the onus of participating in a secure multi party computation from the data owners and capture their computation power in a secure protocol between the \textsf{CSP} and the \textsf{AS} instead. Note that with the \textsf{CSP} in the picture, the secure computation is now reduced to a two-party case irrespective of the number of data owners. Not only does this improve the efficiency of our protocols drastically but is also advantageous from the perspective of ease of system implementation and maintenance. It is so because otherwise we would have had to maintain secure channels between all pairs of data owners, which would become extremely cumbersome with large values of $m$. Moreover all the data owners would have to be online for every program execution. Hence the choice of having a separate server in the form of the \textsf{CSP} is made from the efficiency point of view.
The second assumption of an computationally bounded adversary is inherent in semantically secure cryptographic protocols. Thus we see that the trust assumptions of Crypt$\epsilon$ are in between that of the central differential privacy model and the local differential privacy model - although it is definitely much weaker than that of the central differential privacy model, Crypt$\epsilon$'s trust model is slightly stronger as compared to that of the local differential privacy model owing to the aforementioned premises. %\par Here we present a brief security sketch of the described Crypt$\epsilon$ setting. The formal security analysis is relegated to the Appendix section A.  
%1) The \textsf{AS} has access to only the encrypted records and does not have knowledge of the secret key, $sk$. Every measurement on the data thus needs an interaction with the \textsf{CSP}. Recall that in Crypt$\epsilon$ both the \textsf{AS} and the \textsf{CSP} are responsible for the noise addition.  Hence, the \textsf{CSP} always adds noise of its own before releasing the decrypted data back to the \textsf{AS}. This ensures that the \textsf{AS} is only able to take differentially private measurements of the data.  Moreover, in addition to the \textit{Program Executor} module of the \textsf{AS}, the data analyst communicates the Crypt$\epsilon$ data program and the privacy parameter $\epsilon$ to the \textit{Privacy Engine} module of the \textsf{CSP} as well. This enables the \textsf{CSP} to compute the sensitivity  of the program for itself (required while adding its own noise to the data) and thwart any privacy budget over expenditure attempts, in the semi-honest model. 

%2) The encrypted database is stored in the \textsf{AS} with the \textsf{CSP} having no access to it. Th einteractions between the \textsf{CSP} and the \textsf{AS} can be categorized as   \begin{enumerate}\item Yao's garbled circuits \item decryption of ciphers for differentially private results \item decryption of ciphers for masked data (the random mask hides the true plaintext from the \textsf{CSP}) \end{enumerate}From our discussion in section 3.2 we see that in fact the \textsf{CSP} has only three types of interactions with the \textsf{AS}. Garbled circuit interactions are secure by the semantic security of secure computations and the random masks in  third category of interactions protect the data from the \textsf{CSP}. Thus even the \textsf{CSP} is just allowed only a differentially private view of the database. \end{enumerate}
\begin{comment}
learn any other information about the private datasets Di beyond what is revealed by the
model itself. Even in the case that one of the two servers (MLE or CSP) colludes with some
of the data-owners, they should learn no extra information about the data held by the
honest data-owners. In order to achieve this goal we design a system that can be seen as
multi-party protocol run by the m +2 parties mentioned before and specified by a sequence
of steps. This system (described in Section 4) has the following two-phase architecture:
We assume that the Evaluator and the CSP do not
collude. Each one may try to subvert the system as
discussed above, but they do so independently. More
precisely, at most one of these two parties is malicious:
this is an inherent requirement without which security
cannot be achieved.
• We assume that the setup works correctly, that is all
users obtain the correct public key from the CSP. This
can be enforced in practice with appropriate use of
Certificate Authorities.
Note that is true for any cryptographic primitive and is 
The can actually be avoided by removing the . m+1 secure computation where However this is Thus by capturing the we are having an huge efficincy gain now that teh problem is reduced to antwo-party

\subsection{Protocols} \xh{This might go first with the algorithm box or figure.}
In this section, for each of the three entities we list down the interactions that are initiated by them.
\begin{itemize}\item CSP- The foremost duty of the CSP is to initialize the encryption scheme of Crypt$\epsilon$. Specifically the CSP generates the key pair $(sk,pk)$ for the labeled homomorphic encryption. It stores $sk$ with itself and makes $pk$ public. Note that since only the CSP has access to the secret key $sk$, it is the only entity capable of decryption in Crypt$\epsilon$.
\item Data owners- Recall that each data owner owns a single private record which he/she shares with the AS in the encrypted form as follows. First every data owner represents his/her record in its respective per attribute one-hot-encoding format. For example, if the database schema is given by  $D=<Age,Gender>$ then a data owner with the record $<30, Male>$ would firstly represent it as $\mathcal{E}(D)=<[\underbrace{0,\ldots,0}_{29},1,\underbrace{0,\ldots,0}_{70}],[1,0]>$. This is followed by an element-wise encryption of this record of per attribute one-hot-encodings using the pubic key $pk$. In our aforementioned example, we get $\mathbf{D}=<[\underbrace{Enc(0),\ldots}_{29},Enc(1),\underbrace{\ldots,Enc(0)}_{70}],[Enc(1),Enc(0)]>$. Finally the data owner sends this encrypted record to the AS. Note that this is the only interaction that a data owner ever participates in. All the  query answering are carried out by the AS and the CSP with the data owners being completely off line. \item AS - After receiving the encrypted records from each of the data owners, the AS first collates them into a single encrypted database $\mathbf{\tilde{D}}$. For any subsequent query answering, $\mathbf{\tilde{D}}$ is subjected it to a series of transformations most of which are carried out by the AS by itself. However since the CSP is the only entity capable of decryption, for getting any measurement (even noisy) in the clear the AS has to interact with it. There are precisely two types of interactions between the AS and the CSP \begin{enumerate}\item Yao's Garbled Circuit \item Decryption of encrypted noisy value\end{enumerate}\end{itemize}
\end{comment}

\subsection{Discussion on Crypt$\epsilon$ architecture}

%\xh{We may highlight our design goals (the three desiderata) and then point to later implementation to say how we achieve them. The current writeup below has too many details that reader cannot digest.}

In this section we discuss and justify the architectural choices we make for Crypt$\epsilon$. The Crypt$\epsilon$ setting is based on the premise that there are $m$ individual data owners, each possessing a private data record, and the \textsf{AS} is the primary entity who is interested in learning certain differentially private statistics on the collective data. The goal is to be able to achieve the constant error accuracy guarantees of the \textsf{CDP} setting without relying on a trusted server. In principle cryptographic secure multi-party computation should be able to handle this. However, incautious implementations of cryptographic primitives can be prohibitively costly. This leads to the following desiderata.

\textbf{1)} We should have an efficient implementation of the cryptographic primitives that is practical.

\textbf{2)}The \textsf{AS} should be shouldering the major chunk of the workload for any Crypt$\epsilon$ program execution. Interactions with the \textsf{CSP} should be minimal and only related to data decryption.

\textbf{3)}In the context of differential privacy, sensitivity is the value by which any individual can affect the output of a function. Crypt$\epsilon$ programs should allow easy sensitivity analysis under the composition of the Crypt$\epsilon$ primitives. \\
The first two reasons, have been instrumental behind our choice of using a linear homomorphic encryption for Crypt$\epsilon$. Firstly, linear homomorphic encryptions have very efficient implementations in practice. Moreover the homomorphism allows certain operations (addition and multiplication when extended to labeled homomorphic encryption) to be performed directly on the encrypted data. This enables the \textsf{AS} to perform most of the data transformations by itself which is in cohorts with our second requisite. Specifically for every Crypt$\epsilon$ program, the \textsf{AS} processes the whole database and transforms it into concise representations (like an encrypted scalar or a short vector) which is then decrypted with the help of the \textsf{CSP}. It is interesting to note that we could have had an alternative implementation for Crypt$\epsilon$ where the private database is equally shared between the two servers and they engage in a secret share based secure computation protocol for computing the differentially private answers. However, this would require both the servers to do almost equal amount of work for every program. Such an arrangement would be justified only if both the servers are equally invested in learning the differentially private statistics and is ill-suited for Crypt$\epsilon$ owing to our second requisite. Additionally, a secret-share based computation would be much more computation and communication intensive resulting in a performance hit. Another design choice for Crypt$\epsilon$ could have been to keep the data owners in the loop for every program execution such that some of the data transformations could be pushed down to them. Since the data owners can perform the transformations on the plain text and in parallel, this could potentially improve performance. However this would require the data owners to be on-line during the program execution which might be unwieldy in practice especially with a large number of geographically dispersed data owners.  Keeping the efficiency of our implementation in mind, we use only two instances of simple two-party Yao's garbled circuits for Crypt$\epsilon$. In addition, we propose two optimizations that leverage on the fact that the AS is satisfied with differentially private outputs; this allows  us to expend some of the privacy budget in differentially private pre-processing of the encrypted data. Note that the class of programs supported by Crypt$\epsilon$ is any program that can be expressed as a composition of  Crypt$\epsilon$ primitives followed by arbitrary post-processing. Crypt$\epsilon$ supports 7 transformation primitives and 2 measurement primitives. The noisy measurements allowed are the Laplace mechanism and the Noisy max (see section 4.1.2), two of the most popular and standard differentially private algorithms. The main constraint behind the design of the transformation primitives is that their arbitrary composition should allow seamless sensitivity analysis.  Sensitivity analysis of arbitrary relational algebraic queries is a hard problem, for example sensitivity of conjunctive counting queries with join operator is unbounded \cite{sensitivity}. Hence all the transformations that Crypt$\epsilon$ supports are 1-stable such that the sensitivity analysis of any arbitrary program written using them is straightforward. In fact, we showcase that the proposed Crypt$\epsilon$ primitives are indeed very powerful, enabling us to answer practically useful queries like linear counting queries etc (see section 5). 
\begin{table}[h!]
\small
\centering
\caption {Comparative analysis of the different DP models}
 \begin{tabular}{l| c c c}  \toprule
\multicolumn{1}{c}{\textbf{Features}} & \textbf{LDP}  & \textbf{CDP}  & \textbf{Crypt$\epsilon$}  \\ [0.5ex] 
 \midrule \midrule \# Servers & 1& 1 & 2\\\hline
Trust  & & & Untrusted \\  Assumption & Untrusted & Trusted & Semi Honest \\for Server &  &   &  Non-Colluding  \\ \hline
Data Storage & \multirow{2}{*}{Noisy} & \multirow{2}{*}{Clear} & \multirow{2}{*}{Encrypted} \\in Server & &  &  \\\hline
Adversary & Unbounded & Unbounded & Bounded \\\hline
 Error & $O\Big(\frac{\sqrt(n)}{\epsilon}\Big)$& $O\Big(\frac{1}{\epsilon}\Big)$ & $O\Big(\frac{1}{\epsilon}\Big)$\\\hline
 Impossibility & Everything && \\results & beyond SQ model & None & None\footnotemark\\
  [1ex] 
 \bottomrule
 \end{tabular}
\end{table}
\footnotetext{Theoretically no restriction, however practical constraints maybe present}

%\arc{ Can add another column for Mixnets maybe?}
