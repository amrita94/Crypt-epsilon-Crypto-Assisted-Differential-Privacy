\section{Implementation}\label{sec:implementation}
%To demonstrate the use of Crypt$\epsilon$ operators let us look at the following example. 
%In Section~\ref{sec:implementation} we describe how \system compiles its operators down to protocols that work on encrypted data.
In this section we describe the implementation of \system. 
First we discuss our proposed technique for extending the multiplication operation of \textsf{labHE} to support $n > 2$ multiplicands. Then we describe the implementations of \system operators.  %Based on these implementations, \system can compile a logical program written by the data analyst into a protocol run by the \textsf{AS} and \textsf{CSP} on the encrypted data. 
Note that all the post-processing on the output of differentially private measures are executed in clear. Last, we present a classification of the \system programs.
\eat{
\begin{algorithm}[b]
\caption{$genLabMult$ - generate label for $labMult$}\label{algo:genlabmult}
\small
\begin{algorithmic}[1]
\STATEx
\textbf{Input}: $\mathbf{c_1}=(a_1,d_1)=labEnc_{pk}(m_1)$ and $\mathbf{c_2}=labEnc_{pk}(m_2)$ 
\STATEx where $a_1= m_1-b_1, d_1=Enc_{pk}(b_1)$, $a_2= m_2-b_2, d_2=Enc_{pk}(b_2)$
\STATEx \textbf{Output}: $\mathbf{e}=labEnc_{pk}(m_1\cdot m_2)$
\STATEx \textbf{\textsf{AS}:} 
\STATE Computes $\textbf{e}'=labMult(\mathbf{c_1,c_2}) \oplus Enc_{pk}(r)$ where $r$ is a random mask 
\STATEx  //$e'$ corresponds to $m_1\cdot m_2-b_1\cdot b_2+r$
\STATE Sends $\mathbf{e'},d_1,d_2$ to \textsf{CSP}
\STATEx \textbf{\textsf{CSP}:}
\STATE Computes $e''= Dec_{sk}(\mathbf{e'}) + Dec_{sk}(d_1)\cdot Dec_{sk}(d_2)$
\STATEx //$e''$ corresponds to $m_1\cdot m_2 + r$ 
%\STATE Decrypts $\mathbf{e'}$, to get $Dec_{sk}(\mathbf{e}')=m_1\cdot m_2 -b_2\cdot b_1 + r$
%\STATE Computes $b_1 \cdot b_2$ from $d_1$ and $d_2$.
%\STATE Removes $b_1\cdot b_2$ from $e'$ to compute $e''=m_1\cdot m_2+r$
\STATE Picks a seed $\sigma'$ and label $\tau'$ and computes $b'=\mathcal{F}(\sigma',\tau')$ 
%\STATE Computes $\bar{a}=e''-b'=m_1\cdot m_2 +r -b'$,  and $d'=Enc_{pk}(b')$
\STATE Sends $\bar{e}=(\bar{a},d')$ to \textsf{AS}, where $\bar{a} = e''-b'$ and $d' = Enc_{pk}(b')$
\STATEx //$\bar{a}$ corresponds to $m_1\cdot m_2 + r-b'$.
\STATEx \textbf{\textsf{AS}:}
\STATE Computes true cipher $\mathbf{e}=(a',d')$ where $a'=\bar{a}-r$ %m_1\cdot m_2 - b'$
 \end{algorithmic}
\end{algorithm}
}
  \vspace{-0.2cm} \subsection{\textbf{General $n$-way Multiplication for \textsf{labHE}}}\label{genlab}
\textsf{labHE} scheme is an extension of a \textsf{LHE} scheme where every cipher is now associated with a ``label" that is generated from a pseudo-random function \cite{Barbosa2017LabeledHE}. This extension enables \textsf{labHE} to support multiplication of two \textsf{labHE} ciphers via the $labMult()$ operator.  
\eat{\squishlist
\item $\textbf{labMult}(\mathbf{c}_1,\mathbf{c}_2)$ - On input two \textsf{labHE} ciphers $\mathbf{c}_1=(a_1,d_1)$ and $\mathbf{c}_2=(a_2,d_2)$, it computes a "multiplication" ciphertext  $\mathbf{e}=labMult(\mathbf{c_1,}$ $\mathbf{c_2})=Enc_{pk}(a_1,a_2)\oplus cMult(d_1,a_2) \oplus cMult(d_2,a_1)$. Observe that $Dec_{sk}(\mathbf{e})=m_1\cdot m_2 -b_1 \cdot b_2$.
\item $\textbf{labMultDec}_{sk}(d_1,d_2,\mathbf{e})$ - On input two encrypted masks $d_1,d_2$ of two \textsf{labHE} ciphers $\mathbf{c_1},\mathbf{c_2}$, this algorithm decryts the output $\mathbf{e}$ of $labMult(\mathbf{c_1},\mathbf{c_2})$ as $m_3=Dec_{sk}(\mathbf{e})+Dec_{sk}(d_1)\cdot Dec_{sk}(d_2)$ which is equals to $m_1\cdot m_2$.   
\squishend}
However, $labMult()$ cannot be used directly for a $n$-way multiplication where $n>2$.  It is so because the ``multiplication" cipher $\mathbf{e}=labMult(\mathbf{c_1},\mathbf{c_2})$, where $\mathbf{c_1}$ and $\mathbf{c_2}$ are \textsf{labHE} ciphers, does not have a corresponding label, i.e., it is not in the correct \textsf{labHE} cipher representation. Hence we propose an algorithm $genLabMult$ to generate a label for every intermediary product of two multiplicands so that we can do a generic $n$-way multiplication on the ciphers. The mechanism is detailed in Algorithm~\ref{algo:genlabmult} Appendix \ref{genlab_appen}. %An $n-$way multiplication can be parallelized and requires  $\lceil \log n\rceil$ rounds of communication with the \textsf{CSP}. %Furthermore, it can be shown that the order of multiplication can be parallelized as shown in Figure ~\ref{genlab-fig} (Appendix) and a $n-$way multiplication requires a total of $\lceil \log n\rceil$ rounds of communication with the \textsf{CSP}.
\eat{Note that the mask $r$ protects the value of $(m_1\cdot m_2)$ from the \textsf{CSP} (Step 3) and $b'$ hides $(m_1\cdot m_2)$ from the \textsf{AS} (Step 6). 
For example, suppose we want to multiply the respective ciphers of  $4$ messages $\{m_1,m_2,m_3,m_4\} \in \mathcal{M}^4$ and obtain $\mathbf{e}=labEnc_{pk}(m_1\cdot m_2\cdot m_3 \cdot m_4)$. For this, the \textsf{AS} first generates $\mathbf{e_{1,2}}=labEnc_{pk}(m_1\cdot m_2)$ and $\mathbf{e_{3,4}}=labEnc_{pk}(m_3\cdot m_4)$ using Algorithm~\ref{algo:genlabmult}. Both operations can be done in parallel in just one interaction round between the \textsf{AS} and the \textsf{CSP}. In the next round,  the \textsf{AS} can again use Algorithm~\ref{algo:genlabmult} with inputs $\mathbf{e_{1,2}}$ and $\mathbf{e_{3,4}}$ to obtain the final answer $\mathbf{e}$. %consider a case of mu Now with the true \textsf{labHE} cipher $\mathbf{c}=(a',d')$ for the product the \textsf{AS} can compute further multiplications on it. 
Thus for a generic $n-way$ multiplication the order of multiplication can be, in fact, parallelized as  shown in Figure ~\ref{genlab-fig} (Appendix) to require a total of $\lceil \log n\rceil$ rounds of communication with the \textsf{CSP}.}
\subsection{Operator Implementation}
%Now let us explain the implementation details of the aforementioned Crypt$\epsilon$ operators.  
We now briefly summarize how \system operators are compiled into protocols that the \textsf{AS} and \textsf{CSP} can run on encrypted data records.  Details are presented in  Appendix~\ref{app:implement_operators}.

\stitle{\textsf{Project}} $\project_{\bar{A}}(\cdot)$: The implementation of this operator simply drops off all but the attributes in $\bar{A}$ from the input table $\encT$ 
and returns the truncated table $\encT'$.

\stitle{\textsf{Filter}} $\filter_{\phi}(\cdot)$: Let $\phi$ be a predicate on a single attribute of the form $r.A_j \in V_{A_j}$. Row $i$ satisfies the filter if one of the bits corresponding to positions in $V_{A_j}$ is 1. Thus the filter bit corresponding to row $i$ is set to: $\encB[i] = labMult(\encB[i], \bigoplus_{l\in V_{A_j}}\tilde{\bf{v}}_j[l])$. Multi-attribute \eat{filter} implementation is detailed in  Appendix~\ref{app:implement_operators}.

\stitle{\textsf{CrossProduct}} $\crossproduct_{A_i,A_j\rightarrow A'}(\cdot)$: The crossproduct between two attributes are computed using $genLabMult()$ described above.

\stitle{\textsf{Count}} $\countagg(\cdot)$:  This operator simply  adds up the bits in $\encB$ corresponding to input table $\encT$, i.e., $\bigoplus_{i}^m \encB[i]$.

\stitle{\textsf{GroupByCount*}} $\groupbystar_{A}(\cdot)$: The implementation steps for \textsf{Project}, \textsf{Filter} and \textsf{Count} are reused here. First, \system projects the input table $\encT$ on attribute $A$, i.e. $\encT_1 = \project_A(\encT)$. Then, \system loops each possible value of $A$. For each value $v$, \system initializes a temporary $\encB_v=\encB$ and filters $\encT'$ on $A=v$ to get an updated $\encB'_v$. Last, \system counts the number of 1s in $\encB'_v$ and release the counts. 

\stitle{\textsf{GroupByCount }} $\groupbystar_A(\mathbf{\tilde{T}})$: The implemenation of this operator is summarized in Algorithm~\ref{groupby-imp} (in Appendix~\ref{app:implement_operators}). First, the \textsf{AS} uses the $\textsf{GroupByCount}^*$ operator to generate the encrypted histogram $\encV$ for attribute $A$. Since each entry of $\mathbf{V}$ is a count of records, its value ranges from $\{0,...,m\}$. The \textsf{AS} then masks $\encV$ (step 2) and sends it to the \textsf{CSP}. The purpose of this mask is to hide the true histogram from the \textsf{CSP}. Next the \textsf{CSP} generates the encrypted one-hot-coding representation for this masked histogram $\boldsymbol{\tilde{\mathcal{V}}}$ (steps 4-5) and returns it back to the \textsf{AS}. %Notice that each entry of $\boldsymbol{\tilde{\mathcal{V}}}$ is a $m$-length vector. 
The \textsf{AS} can simply rotate $\boldsymbol{\tilde{\mathcal{V}}}[i], i \in [|V|]$ by its respective mask value $M[i]$ (step 7) and get back the true encrypted histogram in one-hot-coding $\tilde{\encV}$.
%Note that the \textsf{GroupByCount} operator could have an alternative implementation using a garbled circuit that takes as input the encrypted vector and outputs the corresponding one-hot-coding representation. However this would require the circuit to decrypt and re-encrypt $O(m)$ data inside it which would be very costly. 

\stitle{\textsf{CountDistinct}}  $\countdistinct(\cdot)$: This operator can be implemented using \textsf{GroupByCount} followed by a \textsf{Filter}. We present an optimized implementation in the appendix.





\stitle{\textsf{Laplace }}$\lap_{\epsilon,\Delta}(\mathbf{V})$:  The \textsf{Laplace} operator  has two phases (since both \AS and \CSP adds Laplace noise). In the first phase,  the \textsf{AS} adds an instance of encrypted Laplace noise $\eta_1 \sim Lap(\frac{\Delta}{\epsilon})$ to the encrypted input \eat{(step 1 in Algorithm ~\ref{lap})} to generate $\mathbf{\hat{\mathcal{V}}}$. This is the input to the second phase which is executed by the \textsf{CSP}. Here the \textsf{CSP} decrypts $\mathbf{\hat{\mathcal{V}}}$ and adds a second instance of the Laplace noise $\eta_2 \sim Lap(\frac{\Delta}{\epsilon})$ to generate the final noisy output $\hat{V}$ in the clear. %(steps 3-4)
The \textsf{Laplace} operator with an encrypted scalar $\encC$ as the input is implemented in a similar way.
 %Another observation is that this double noise addition does not affect the differential privacy guarantee. After the addition of the first instance of noise by the \textsf{AS}, the second can be seen as a post-processing step. Hence our results Crypt$\epsilon$ programs are still differentially private by Theorem 2.
%\textit{Note:} Following our discussion on the operator implementations in this section and Appendix C, we see that the major chunk of the work for almost all the transformation operators is carried out the \textsf{AS} by itself. This conforms to our second requirement in section.

\stitle{\textsf{NoisyMax}} $\noisymax_{\epsilon,\Delta}(\cdot)$: This operator is implemented using two-party computation between \textsf{AS} and \textsf{CSP} using garbled circuits. Details are in  Appendix~\ref{app:implement_operators}.

\eat{\begin{algorithm}
\small{
\caption{\textsf{Laplace }$\lap_{\epsilon,\Delta}(\mathbf{V})$}
\begin{algorithmic}[1]
\STATEx
\textbf{Input}: $\encV$
\STATEx \textbf{Output}: $\hat{V}$
\STATEx \textbf{\textsf{AS}:} \STATE Generates a noisy vector $\hat{\encV}$  as \begin{gather*}\hat{\mathbf{V}}[i] = \mathbf{V}[i]\oplus labEnc_{pk}(\eta[i]),\\ \eta \sim [Lap(\frac{1}{\epsilon})]^{|V|}, i \in [|V|] \end{gather*}
\STATE Sends $\hat{\mathbb{\mathcal{V}}}$  to \textsf{CSP}
\STATEx \textbf{\textsf{CSP}:}
\STATE Decrypts $\mathbf{\hat{\mathcal{V}}}$ to get $\hat{\mathcal{V}}[i]=labDec_{sk}(\mathbf{\hat{\mathcal{V}}}[i]), i \in [|V|]$
\STATE Generates a the final noisy vector $\hat{V}$ as follows 
\begin{gather*} \hat{V}[i]=\hat{\mathcal{V}}[i]+\eta'[i], i \in [|V|], \eta' \sim [Lap(\frac{1}{\epsilon})]^{|\hat{V}|} \end{gather*}
\STATE Returns $\hat{V}$ to \textsf{AS}
 \end{algorithmic} \label{lap}
}
\end{algorithm}} %The implementation for the \textsf{Laplace} operator is given by Algorithm ~\ref{lap}.

\subsection{Classification of \system Programs}
\system programs are grouped into three classes based on the number and type of interaction between the \textsf{AS} and the \textsf{CSP}. 

\stitle{Class I : Single Decrypt Interaction Programs}\\
Recall that the transformation operators output encrypted data.  Since  the \textsf{CSP} has exclusive access to the secret key, it is the only party in \system capable of decryption. Thus for releasing any result (albeit noisy) in the clear, the \textsf{AS} needs to interact at least once with the \textsf{CSP}. \system supports this type of interactions via the two measurement operators. Some \system programs require only a single interaction of this type at the very end to release the noisy output. All other transformations can be performed by the \textsf{AS} via homomorphic operations on the encrypted data records. Typically these programs filter the database on a single attribute. Examples of this type of programs are P1, P2 and P3 from Table~\ref{tab:programexamples}. The post-processing step in P1 is done in the clear and hence requires no more interactions with the \textsf{CSP}.



\stitle{Class II : \textsf{LabHE} Multiplication Interaction Programs}\\
Recall that \textsf{labHE} allows multiplication of two ciphers. \system can support a general $n$-way multiplcation of ciphers for $n > 2$ as described in Section~\ref{genlab}. However it requires intermediate interactions with the \textsf{CSP}. Thus all \system programs that require multiplication of more than two ciphers need interaction with the \textsf{CSP}.  All programs that filter the database on more than three attributes would thus fall under this class. P4 and P5 from Table~\ref{tab:programexamples} are in this class.

\stitle{Class III : Other Interaction Programs}\\
 The \textsf{GroupBy} operator requires an intermediate interaction with the \textsf{CSP} (for generating the encrypted one-hot-coding). The \textsf{CountDistinct} operator also uses a garbled circuit (Appendix~\ref{app:implement_operators}) and hence requires interactions with the \textsf{CSP}. This is in addition to the interaction required for decrypting the noisy answer (as explained in Class I above). Therefore, any program with the \textsf{GroupBy} or \textsf{CountDistinct} operator requires at least two rounds of interaction. P6 and P7 from Table~\ref{tab:programexamples} are examples of this class. 


\eat{
\begin{frame}{}
  \begin{center}
    \scalebox{0.75}{
    \begin{minipage}{1\linewidth}
\begin{algorithm}[H]
\caption{\textsf{GroupByCount }$\groupby_A(\mathbf{\tilde{T}})$}
\begin{algorithmic}[1]
\STATEx
\textbf{Input}: $\mathbf{\tilde{T}}$
\STATEx \textbf{Output}: $\tilde{\encV}$
\STATEx \textbf{\textsf{AS}:} \STATE Computes $\mathbf{V}=\groupbystar_{A}(\encT)$.
\STATE Masks the encrypted histogram $\mathbf{V}$ for attribute $A$ as follows \begin{gather*}\boldsymbol{\mathcal{V}}[i]= \mathbf{V}[i] \oplus labEnc_{pk}(M[i])\\M[i] \in_R [m], i \in [|V|]\end{gather*}
\STATE Sends $\boldsymbol{\mathcal{V}}$ to \textsf{CSP}.
\STATEx \textbf{\textsf{CSP}:}
\STATE Decrypts  $\boldsymbol{\mathcal{V}}$ as $\mathcal{V}[i]=labDec_{sk}(\boldsymbol{\mathcal{V}}), i \in [|V|]$.\STATE Converts each entry of $\mathcal{V}$ to its corresponding one-hot-coding and encrypts it, $\boldsymbol{\tilde{\mathcal{V}}}[i]=labEnc_{pk}(\tilde{\mathcal{V}[i]}), i \in [|V|]$
\STATE Sends $\boldsymbol{\tilde{\mathcal{V}}}$ to \textsf{AS}.
\STATEx \textbf{\textsf{AS}}:
\STATE  Rotates every entry by its corresponding mask value to obtain the desired  encrypted one-hot-coding $\boldsymbol{\tilde{V}}[i]$. \begin{gather*}\boldsymbol{\tilde{V}}[i]=RightRotate(\boldsymbol{\tilde{\mathcal{V}}},M[i]), i \in [|V|]\end{gather*} 
 \end{algorithmic} \label{groupby-imp}
\end{algorithm} 
 \end{minipage}}
  \end{center}
\end{frame}
}
