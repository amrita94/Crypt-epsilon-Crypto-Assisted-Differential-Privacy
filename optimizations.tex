\section{Optimizations}
In this section we propose two optimizations that leverages on the fact that we allow a differentially private view of our private database. This DP based optimizations help in reducing the performance cost significantly which would have been impossible with just secure multi-party computation.

\begin{enumerate}
\item Index- Consider a conjunctive query predicate $A_1==v_1 \wedge A_2==v_2 \wedge A_3==v_3 $. If it so happens that the number of records satisfying $A_1==v_1$ is very low compared to the total number of records, i.e., $ct_{A_1,v_1} << m$, then if a selection operation is performed alone on attribute $A_1$ then the size of the dataset to be considered for the subsequent clause $A_2==v_2 \wedge A_3==v_3$ reduces to only $ct_{A1,v1}$ as opposed to the whole dataset (size $m$). Our index optimization leverages on this idea - we create an index by sorting the database on an attribute of choice $A$. There are two heuristics that can be considered for selecting this indexing attribute $A$ - firstly $A$ should be a very frequently queried upon attribute. This is intuitive as this would mean a larger fraction of the queries will benefit from this optimization. Secondly if $\{v_1,...v_n\} \subset dom(A)$ is the set of most frequently queried values for attribute $A$, then $ct_{A,v_i}, i \in [n] << m$. This would ensure that the first selection operator performed alone on $A$ will filter out majority of the records and reduce the  dataset size to be considered for the subsequent predicate. The optimization is implemented via a garbled circuit that \begin{enumerate}\item takes the entire database $\boldsymbol{\mathcal{\tilde{D}}}$ as an input and the attribute $A$ as an input from the AS.
\item takes the secret key $sk$ as an input from  the CSP \item Decrypts $\boldsymbol{\mathcal{\tilde{D}}}$ \item Sorts the decrypted database on $A$, i.e., the first $ct_{A,1}$ rows are the ones with value $v_1$ for attribute $A$, the next $ct_{A,2}$ are  the records with value $v_2$ for attribute $A$ and so on. \item  re-encrypts the sorted database \item Construct a $s_A$ lengthed vector $\hat{V}$ such that $\bar{\hat{V}}[i]=ct_{A,i}+\eta_i, i \in [s_A]$ where $\eta_i$ is a random laplace noise drawn from the distribution $Lap(\frac{1}{\epsilon'}), \epsilon' < \epsilon $ \item Return $\bar{\hat{V}}$ and sorted $\boldsymbol{\mathcal{\tilde{D}}}_{sort}$\end{enumerate}
Next the AS computes a CDF, $\bar{\hat{\mathcal{C}}}$ over the noisy counts in $\bar{\hat{V}}$ using inference based on the Non Negative Least Squares technique \arc{[add ref]}.
For answering queries of the form $\phi=A_1==v_1\wedge \ldots \wedge A==v \wedge \ldots \wedge A_n==v_n$, ideally we just need to compute for $A_1==v_1\wedge \ldots \wedge A_n==v_n$ on $ct_{A,v}$ number of records starting from position $\sum_{i=1}^{i=v-1}ct_{A,i}$ of $\boldsymbol{\mathcal{\tilde{D}}}_{sort}$. 

However the AS has access only to the noisy CDF over $ct_{A,i}$. Note that when $\bar{i}_{start}=\bar{\hat{\mathcal{C}}}[v-1] < \sum_{i=1}^{i=v-1}ct_{A,i}$ and $\bar{i}_{end}= \bar{\hat{\mathcal{C}}}[v-1] > i_{start}+ct_{A,v}$, i.e., the indices computed from the noisy values  saddle over the true records satisfying $A==v$, then although we end up loosing in performance a bit, we are still guaranteed to compute the exact non-noisy count for records satisfying $\phi$. 

In all other cases, we end up disregarding some of the records that satisfy $A==v$, some of these rejected records in fact might additionally satisfy $A_1==v_1 \wedge \ldots \wedge A_n==v_n$. Thus we might get inaccurate answer for query predicate $\phi$ (note that here we are talking about the encrypted true count of the given query predicate that is computed by the AS via a series of transformations before applying the LaplaceMechanism primitive).  An effective heuristic to tackle this can be to compensate for the expected laplacian error as follows  $\bar{i}_{start}= \bar{\hat{\mathcal{C}}}[v-1]-\frac{2}{\epsilon}$ and $\bar{i}_{end}=\bar{\hat{\mathcal{C}}}[v]+\frac{2}{\epsilon}$. Also note that answering differentially private  range queries   on attribute $A$ can also be directly done from the noisy CDF $\bar{\hat{\mathcal{C}}}$
 %\item GroupBy*($\mathbf{V},sk$)- This primitive is an extension of the previous GroupBy transformation. 
 \item Range Tree- Range queries constitute a very popular category of queries for typical databases and range trees are a popular data structure constructed to speed up range query answering. A 1-dimensional range tree for an attribute $A$ is an ordered data structure such that the leaf nodes correspond to the individual counts $ct_{A,i}$, $i$ increasing from left to right while the parent node stores the sum of the counts of its children. Hence an useful optimization for our setting can be pre-computing the range tree for some attributes. In Crypt$\epsilon$ we construct a noisy range tree for some of the attribute. The sensitivity for each such noisy count is $\log k$ where $k$ is the domain size of the attribute. For answering any arbitrary range query, we need to access at most $2\log k$ nodes of the range tree. Thus to answer all possible range queries for the given attribute, the total squared error accumulated is $O(\frac{k^2\log }{\epsilon^2})$. In contrast for the naive case, we would have incurred error $O()$. Hence this range tree optimization not only gives us a huge performance boost but also results in better answer accuracies. \end{enumerate}
\paragraph*{Optimized Crypt$\epsilon$ programs}
Let us reconsider the example programs covered in section. Both program 1 and program 2 can be optimized by constructing a range tree over attribute $Age$. Programs  4,5 and 6 on the other hand can be improved by the differentially private index over attribute $Age$.