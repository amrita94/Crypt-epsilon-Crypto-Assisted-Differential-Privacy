\section{\system Primitives}\label{sec:primitives}
\system provides a set of \system primitives to the data analyst.
A sequence of these primitives forms a program which can be run by \system.
In this section, we first define these primitives and then show how to use these primitives to write useful analysis programs.

\newcommand{\encD}{\boldsymbol{\tilde{D}}}
\newcommand{\crossproduct}{\times}
\newcommand{\project}{\pi}
\newcommand{\filter}{\sigma}
\newcommand{\countagg}{count}
\newcommand{\groupbystar}{\gamma^{*,count}}
\newcommand{\groupby}{\gamma^{count}}
\newcommand{\countdistinct}{count^*}
\newcommand{\encT}{\boldsymbol{\tilde{T}}}
\newcommand{\encB}{\boldsymbol{\tilde{B}}}
\newcommand{\encC}{\boldsymbol{C}}
\newcommand{\encV}{\boldsymbol{V}}
\newcommand{\lap}{Lap}
\newcommand{\noisymax}{NoisyMax}

\input{table}


\subsection{Transformation Primitives}
The analyst is given a database schema $(A_1,\ldots,A_k)$ and an encrypted instance of this database, represented by $\encD$.
There are two types of Crypt$\epsilon$ primitives:  (i) transformations and (ii) measurements, as summarized in Table~\ref{tab:primitives}.


\stitle{Transformation.} The first type of primitives take as input an encrypted data and output a different encrypted data. We use $\encT$ to represent a table of $n$ rows and $k$ columns/attributes, where each attribute value is represented by encrypted one-hot-encoding of the value. For each $\encT$, we have a encrypted bit vector $\encB$ of size $n$ to indicate whether the record is relevant to the program at hand. If $\mathbf{B}[i] =Enc_{pk}(1)$, then the $i^{th}$ record is to be considered for answering the current program and vice versa. \xh{Describe the functionalities of cross product,project,filter here}. Another data format is a vector of encrypted counts, denoted by $\bf{V}$. If these counts are in one-hot-encoding, they are represented by $\encV$. \xh{Describe the functionalities of Count, GroupbyCount*, GroupbyCount, and CountDisctinct}.

\xh{Do not need to mention whether AS or CSP carries out these primitives or using LabEnc or not. }



%The input to Crypt$\epsilon$ is an encrypted instance of a database $\boldsymbol{\tilde{\mathcal{D}}}$ with a single relational schema $\langle \mathcal{A}_1,\mathcal{A}_2, . . . ,\mathcal{A}_l\rangle$. Each attribute $\mathcal{A}_i$ is assumed to be discrete (or suitably discretized) and represented in one-hot-coding form.

\eat{
Transformation primitives take as input an encrypted source variable (a table of size $x \times y, x,y \in \mathcal{Z}_{\geq 0}$) and output a transformed data source (again  a table $x' \times y', x',y' \in \mathcal{Z}_{\geq 0}$) that is still encrypted. Typically $x$ and $x'$ are equal to $m$, the total number of data owners, i.e., every tuple in the data source tables corresponds to the record of a single data owner. In case $x=1$ or $x'=1$ the data source is an encrypted vector and we represent it as $\mathbf{V}$.
The transformation primitives are mostly carried out by the \textsf{AS} on its own; this is enabled by our use of labeled homomorphic encryption scheme which allows us to perform certain operations, specifically multiplication and addition, directly over the encrypted data. %Only two transformations  (\textsf{GroupBy} and \textsf{CountDistinct}) need to be computed via a secure computation protocol between the \textsf{AS} and the \textsf{CSP}. 
Since these primitives work entirely on encrypted data, they do not expend the privacy budget. However these operators can affect the privacy analysis through their stability. Every transformation in Crypt$\epsilon$ has a well-established stability.
For each record of the database $\boldsymbol{\tilde{\mathcal{D}}}$ (i.e., data corresponding to a single data owner) we maintain an encrypted bit which indicates whether the record is relevant to the program at hand. Let $\mathbf{B}$ represent this bit vector where $\mathbf{B}[i]$ corresponds to this indicator bit for the $i^{th}$ record.  If $\mathbf{B}[i] =Enc_{pk}(1)$, then the $i^{th}$ record is to be considered for answering the current program and vice versa. Only one of the transformation, \textsf{Filter} alters the bit vector $\mathbf{B}$. Before every program execution, $\mathbf{B}$ is initialized to a 1-vector. 
\begin{enumerate}

	\item \textsf{CrossProduct} ($\tilde{\mathbf{T}}, A_i, A_j$) - Given encrypted one-hot-codings for two different attributes $A_1$ and $A_2$ of domain sizes $s_{A_1}$ and $s_{A_2}$ respectively, the goal of this transformation is to compute the encrypted one-hot-coding for the entire two-dimension domain of the new $\lq$attribute' $A_1\times A_2$ of size $s_{A_1}\cdot s_{A_2}$. Thus this transformation takes as input a $x \times y $ table, $\tilde{\mathbf{T}}$ defined over attribute set $A=\{A_1,A_2,...,A_y\}$ where each cell $\tilde{\mathbf{T}}[i,j] , i \in [x], j \in [y], 2 \leq y \leq k$ corresponds to the encrypted one-hot-coding for attribute $A_j$ for the data owner $\textsf{DO}_i$ and outputs a $x \times (y-1)$ table with attribute set $\{A_1\times A_2,A_3,\ldots,A_{y}\}$.  Note that the construction of the one-hot-coding of the full $y$-dimension domain can be computed by repeated application of this transform. 	
    
	
	\item \textsf{Project}($\tilde{\mathbf{T}},A^*$)- In addition to the $ x \times y$ table, $\tilde{\mathbf{T}}$ over attribute set $\{A_1, A_2, ..., A_y\}$, the \textsf{Project} transformation takes a set of attributes $A*=\{A^*_1,...A^*_p\}, p < y$ as inputs. The result of the transformation is defined as the $x \times p$ data source table where each record is just restricted to the attribute set $A^*$, i.e., it discards all other attributes. 
	%Infact it is analogous to the operation of marginalization which is described as follows.
	%Assuming  $A$ and $B$ to be two attributes with finite domains, let $x$ be a vector of counts representing a histogram over the cross product of the domain (with $|A|*|B|$ entries).
	%Marginalization over the attribute $B$ results in a vector of counts on the attribute $A$ alone by adding up counts corresponding to the same value of $A$.  
   
  \item \textsf{Filter}($\tilde{\mathbf{T}},\phi$) - Let $\tilde{\mathbf{T}}$ be an encrypted table of one-hot-codings over attribute set $A=\{A_1,...,A_k\}$, $\phi$ be a  predicate defined over a subset of attributes $A^*\subseteq A$ and $\mathbf{B}$ be the current state of the indicator vector which is stored by the \textsf{AS}. The predicate $\phi$ has to be expressed as a conjunction of range conditions over $A^*$, i.e.,\begin{gather}\phi = \bigwedge_{A \in A^*}(A \in \{v_{1},\ldots,v_{t}\} ) \label{phi} \end{gather} If for some attribute $A \in A^*$, the condition is a equality condition as $A==v$ instead of a range condition, then simply put $v_1=v_t$. For e.g., a condition of this form is find the number of records that satisfy $Age$ in range [30,40] and $Gender$ is male. For each record $r_i, i \in [m]$, the Filter transformation zeros the corresponding indicator bit $\mathbf{B}[i] $ if $\phi(r_i)=False$. $\mathbf{B}[i] $ is kept unchanged otherwise. Thus the \textsf{Filter} transformation suppresses all the records that are extraneous to answering the program at hand (i.e., does not satisfy $\phi$) by explicitly zeroing the corresponding indicator bits and outputs the updated indicator vector. %It takes as input a $x \times 1$ table $\tilde{\mathbf{T}}$, whose every row is an encrypted one-hot-encoding (of the form $\mathbf{\tilde{R}}$) for the attribute of concern $A$, and a vector $\mathbf{C}$ which has encryptions of appropriate non-zero weights for indices that satisfy $\phi$. %Note that $A$ need not be an attribute of the original attribute set $\mathcal{A}$ but can be a new multi-dimension 'attribute' constructed over $\mathcal{A}^* \subseteq \mathcal{A}$, i.e., $A= \prod_{A*_i \in \mathcal{A}^*  }A^*_i$. 
    \item{\textsf{Count}($\mathbf{T}$) } - The \textsf{Count} transformation outputs the encrypted value of the non-noisy true count for the program at hand. For answering linear counting queries, typically \textsf{Count}  is the last transformation to be applied and is immediately preceded by a \textsf{Filter} transformation. Recall that the \textsf{Filter} transformation sets bit $i \in [m]$ to be 1 (encrypted) if the $i^{th}$ record satisfies the filter condition and 0 otherwise and outputs this encrypted $m\times 1$ vector. Hence the \textsf{Count} primitive simply adds up all the entries of this bit vector $\mathbf{B}$ and  outputs the sum which is a single encrypted value. 
    \item{\textsf{GroupBy*}($\mathbf{\tilde{T}},A$)}- The purpose of the \textsf{GroupBy*} transformation is to essentially bucket the input $x\times y$ table $\mathbf{\tilde{T}}$ into groups of records having the same value for an attribute of choice $A$. The output of this transformation is an $1\times s_A$ encrypted  vector $\mathbf{V}$  where each vector element $\mathbf{V}[i], i \in [s_A]$ represents the encrypted count of the number of records in $\boldsymbol{\tilde{\mathcal{D}}}$ having value $v_{i}$ for attribute $A$. Thus \textsf{GroupBy*} essentially returns an encrypted histogram for $A$.
    This primitive serves as a preceding transformation for other Crypt$\epsilon$ primitives like \textsf{NoisyMax}, \textsf{CountDistinct} et al.
     \item{\textsf{GroupBy}($\mathbf{\tilde{T}},A$)-} The \textsf{GroupBy} transformation is similar to the aforementioned \textsf{GroupBy*} transformation. The only difference between the two is that, the former outputs the encrypted one-hot-coding of the respective counts. That is, the output of \textsf{GroupBy}($A$)  is an $s_A$ lengthed encrypted vector $\tilde{\mathbf{V}}$ such that each element, $\tilde{\mathbf{V}}[i], i \in [s_A]$ represents the encrypted one-hot-encoding of the number of records in $\boldsymbol{\tilde{\mathcal{D}}}$ having value $v_{i}$ for attribuet $A$. This transformation allows us to answer queries based on the count of a particular value for attribute $A$.
     %Note that since for \textsf{GroupBy} we need to create the one-hot-coding of the counts, this requires an interaction with the \textsf{CSP}.
     \item {\textsf{CountDistinct}($\mathbf{V}$)-} As mentioned before, the \textsf{CountDistinct} primitive takes as input an encrypted vector $\mathbf{V}$ which is the output of a \textsf{GroupBy*}($A$) primitive for some attribute $A$. Thus the \textsf{CountDistinct} primitive  returns the number of distinct values of $A$ that appear in the records of $\boldsymbol{\tilde{\mathcal{D}}}$ by counting the non-zero entries of $V$.  
\end{enumerate}
%Note that the first four transformations namely \textsf{CrossProduct, Project, Filter} and Count are performed by the \textsf{AS} alone. Only for transformation \textsf{GroupBy} the \textsf{AS} engages in a secure computation protocol with the \textsf{CSP}.

}


\stitle{Measurement.} The measurement operators include two important differentially private mechanisms: Laplace mechanism $\lap$ and NoisyMax mechanism.
\xh{Do not need to mention CSP or AS here, this is all hidden from data analyst, but focus on what Laplace and noisy max is and what it can achieve.}

Laplace mechanism, denoted by  $\lap_{\epsilon,\Delta}(\cdot)$ takes a vector of encrypted counts $\bf{V}$ and privacy paramters $\epsilon,\Delta$ as input, and outputs a noisy plaintext vector $\hat{V}$, where $\epsilon$ is the privacy budget and $\Delta$ is defined as the maximum change to the count vector  $\bf{V}$ if changing one user's input. \xh{Add formal description and state the DP property.}

NoisyMax mechanism, denoted by ....



\eat{
Thus they expend the privacy budget and require secure computation between the \textsf{AS} and the \textsf{CSP}. 
\begin{comment} All measurement operators must involve joint computation with the \textsf{CSP}. Note that the requisite noise to be added to ensure differentially privacy has to be jointly added by both the \textsf{AS} and the \textsf{CSP}. It is so because, had only either one of the servers added the noise, then that server would be able to retrieve the true non-noisy answer by simply de-noising the published differentially private answer. This means that the sensitivity of the program being executed should be known to both the servers. This poses no hindrance in our setting  since the program is public, the  sensitivity computation can be performed very easily by observing the sequence of the preceding transformations.
\end{comment}
\begin{enumerate}
	\item \textsf{Laplace}($\mathbf{V},\epsilon$) - In the Laplace mechanism, in order
to publish $f(D)$ where $f : D \mapsto R$, $\epsilon$-differentially private mechanism $\mathcal{M()}$ 
publishes $f(D) + Lap\Big(\frac{\Delta f}{\epsilon}\Big)$  
where $\Delta f = \max_{D,D'}||f(D)-f(D')||_1$ is known as the sensitivity of the query. The p.d.f of $Lap(b)$ is given by\begin{gather}\mathbf{f}(x)={\frac  {1}{2b}}e^{ \left(-{\frac  {|x-\mu |}{b}}\right)}\end{gather} The sensitivity of the function $f$ basically captures the magnitude by which a single individual's data can change the function $f$ in the worst case. Therefore, intuitively, it captures the uncertainty in the response that we must introduce in order to hide the participation of a single individual. For counting queries the sensitivity is 1. The \textsf{Laplace} primitive enables the \textsf{AS} and the \textsf{CSP} to add two separate instances of random laplace noise to the true result of a counting query for generating a differentially private output. It takes an input an encrypted vector $\mathbf{V}$ (could be a scalar too) and adds two instances of noise drawn from $[Lap(\frac{1}{\epsilon})]^{|V|}$ to it.

	\item \textsf{NoisyMax}($\mathbf{V},\epsilon, k$)-Noisy-Max is a type of differentially-private selection mechanism where the goal is to determine the counting query with the highest value out of $n$ different counts.  
	The algorithm works as follows. First, generate each of the counts and then add independent Laplace noise from the distribution $Lap(\frac{1}{\epsilon})$ to each of them. The index of the largest noisy count is then reported as the noisy max.
	This has two fold advantage over the naive implementation of finding the maximum count.
Firstly, noisy-max applies "information minimization" as rather than releasing all the noisy counts
and allowing the analyst to find the max and its index, only the
index corresponding to the maximum is made public.
Secondly, the noise added is much smaller than that in the case of the naive implementation (it has sensitivity $\Delta f=m$). Thus the \textsf{NoisyMax} primitive takes as input of encrypted vector where each vector element is a count. It then adds noise drawn from $Lap(\frac{1}{\epsilon})$ to each vector element and computes the indices of the top k elements.
\end{enumerate}
}
