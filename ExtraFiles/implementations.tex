\section{Implementation}\label{sec:implementaion}
%To demonstrate the use of Crypt$\epsilon$ primitives let us look at the following example.
\label{implementation}
In this section we describe the implementation of Crypt$\epsilon$. First we discuss our novel proposed technique for extending the $labMult()$ operation of \textsf{labHE} to support $n > 0$ multiplicands. Then we describe the implementations for each primitive. Last, we use the example programs from the previous section to illustrate the performance of \system.



\subsection{\textbf{General n-way multiplication for \textsf{labHE}- $genLabMult()$}}
\xh{Try to rewrite this into algorithmic box.}
Consider the case where we want to multiply the respective ciphers of  $n$ messages $\{m_1,...m_n\} \in \mathcal{M}^n$. Note that the reason why we can't simply use $labMult$ for a generic $n-$ way multiplication is because, the "multiplication" cipher $\mathbf{d}=labMult(\mathbf{c_1},\mathbf{c_2})$ does not have  a corresponding label. Thus for generalizing the $labMult()$ operation for $n$ multiplicands what we have to do is to generate a label and a seed for every intermediary product of two multiplicands. This can be done in the following way-  \\
Consider two ciphers $\mathbf{c_1}$ and $\mathbf{c_2}$ corresponding to messages $m_1$ and $m_2$. The \textsf{AS} computes
$\textbf{d}'=labMult(\mathbf{c_1,c_2}) \oplus Enc_{pk}(r)$ where $r$ is a random mask such that $Dec_{sk}(\textbf{d}')=m_1\cdot m_2-b_1\cdot b_2+r$. The \textsf{AS} sends $\textbf{d}'$ to the \textsf{CSP}. Now the \textsf{CSP} decrypts it and removes  $b_1\cdot b_2$ to get plaintext $d'=m_1\cdot m_2+r$. Note that the mask $r$ protects the value of $m_1\cdot m_2$ from the \textsf{CSP}. The \textsf{CSP} next assigns a seed $\sigma'$ and label $\tau'$ to the product and returns the value $\bar{c}=(\bar{a},c')$ to the \textsf{AS} where $\bar{a}=m_1\cdot m_2 -b' +r$, $b'=\mathcal{F}(\sigma',\tau')$ and $c'=Enc_{pk}(b')$ to the \textsf{AS}. The \textsf{AS} can subtract $r$ from $\bar{a}$ to obtain the  true value of the hidden message $a'=m_1\cdot m_2 - b'$. However since $b'$ is not known to the \textsf{AS}, $m_1\cdot m_2$ remains hidden from the \textsf{AS} as well. Now with the true cipher $\mathbf{c}=(a',c')$ for the product the \textsf{AS} can compute further multiplications on it.
For a generic $n-way$ multiplication the order of multiplication can be, in fact, parallelized as  shown in Figure 2 to require a total of $\lceil \log n\rceil$ rounds of communication with the \textsf{CSP}.
\begin{figure}\includegraphics[height=4cm,width=8cm]{kk.png} \caption{ $genLabMult()$ - Batching of multiplicands for \textsf{labHE}} \end{figure}\\


\subsection{Primitive Implementation}
Now let us explain the implementation details of the aforementioned Crypt$\epsilon$ primitives.
\xh{Write complicated implementation into algorithmic box.}

\begin{enumerate}\item \textsf{CrossProduct}($\tilde{\mathbf{T}}, A_i, A_j$): Let $D_1$ and $D_2$  be the encrypted one-hot-coding corresponding to two  values $v_1$ and $v_2$ (integral representation) for attributes $A_1$ and $A_2$ respectively. The corresponding encrypted one-hot-encoding for the two-dimensional attribute $A_1\times A_2$ is given by  \begin{gather} D_{1\times 2}[(i-1)\cdot s_{A_2}+j] = labMult(D_1[i], D_2[j])\\ i \in [s_{A_1}], j \in [s_{A_2}]\end{gather} For this particular case, only $D_{1 \times 2}[(v_1-1)\cdot s_{A_2}+v_2]=Enc(1)$ while all other indices will equate to $Enc(0)$. Note that when computing the one-hot-encoding for a t-dimensional attribute $t > 2$,  for the actual implementation, instead of calling $t$ iterative instances of \textsf{CrossProduct}() we use the $genLabMult()$ operator of labeled homomorphic encryption to speed up the computation. \item \textsf{Project}($\tilde{\mathbf{T}}, A^*$)- The implementation of the \textsf{Project} transformation is very straightforward, it simply drops off all the attributes from $\tilde{\mathbf{T}}$ and returns the truncated table. \item \textsf{Filter}($\mathbf{\tilde{T}},\phi$)-  As discussed in the preceding section, the predicate $\phi$ is expressed in a special form of conjunctions of range conditions given by eq \ref{phi}. Now for a range condition $A \in \{v_1,...v_t\}$, assuming $\mathbf{\tilde{R}_A}[i]$ is the corresponding one-hot-coding for the $i^{th}$ record's value for attribute $A$,  consider the following \begin{gather}\mathbf{c}_A^i=\bigoplus_{j=1}^{t}\tilde{\mathbf{R}}_{A}[i][v_1]\end{gather} where $\tilde{\mathbf{R}}_{A}[i][v]$ is the $v^{th}$ index of corresponding one-hot-coding. Clearly if the $i^{th}$ record satisfies the condition $A \in \{v_1,...v_t\}$, then exactly one of the values in $\{\tilde{\mathbf{R}}_{A}[i][v_j]\}, j \in \{1,...,t\}$ will be a cipher for $1$. Thus $c_A^i=1$ if record $i$ satisfies the range condition and 0 otherwise. If the condition is instead an equality predicate $A==v$ then $\mathbf{c}_A^i=\tilde{\mathbf{R}}_{A}[i][v]$. Now considering $\phi$ is given by eq \ref{phi}, let us define\begin{gather}\mathbf{c}^i=genLabMult(\mathbf{c}^i_{A_1},...,\mathbf{c}^i_{A_r})\\A^*=\bigcup_{j=1}^rA_j\end{gather} It is easy to see that $c^i$=1 iff record $i$ satisfies $\phi$. Let $\mathbf{B}'$ be the indicator vector before the execution of the current instance of the \textsf{Filter} transformation. The final step is to multiply the $\mathbf{c}^i$s with the corresponding indicator bits and obtain the updated indicator vector $\mathbf{B}$ as follows \begin{gather}\mathbf{B}[i]=labMult(\mathbf{c}^i,\mathbf{B}'[i])\end{gather}
The above step zeros out some additional records which were found to be extraneous by some preceding filter conditions. Clearly $\textbf{B}$ is the output of the \textsf{Filter} transformation.
\\\textbf{Avoid Indicator Vector Multiplication}\\
When the \textsf{Filter} transformation is applied for the very first time in a Crypt$\epsilon$ program and the input predicate is conditioned on a single attribute $A \in \{v_1,...,v_k\}$, then we can do the following optimization. Consider \begin{gather}\mathbf{b}[i]=\bigoplus_{j=1}^k \mathbf{\tilde{R}}_A[i][v_j], i \in [m]\end{gather} where $\mathbf{\tilde{R}}_A[i]$ is the one-hot-coding for attribute $A$ for the $i^{th}$ record. Since this is the first instance of the \textsf{Filter} primitive, the current indicator vector $\mathbf{B}$  will be all 1-vector. Thus $\mathbf{b}$ is itself the updated indicator vector  and we can avoid the unnecessary multiplication $labMult(\mathbf{b[i]},\mathbf{B}[i])$.   \item \textsf{Count}($\mathbf{\hat{T}}$) - Recall that the \textsf{Count} transformation is always preceded by a \textsf{Filter} transformation. Hence it inputs the $m \times 1$ indicator bit vector $\mathbf{\hat{T}}=\mathbf{B}$ and simple adds up its entries to return the true encrypted count  \begin{gather}\mathbf{C}=\bigoplus_{i=1}^m\mathbf{B}[i]\end{gather}%\item GroupBy*($\mathbf{V},sk$)- This primitive is an extension of the previous GroupBy transformation.
 \item \textsf{GroupBy*}($\mathbf{\tilde{T}},A$) - The \textsf{GroupBy*} transformation   makes use of three other transformations \textsf{Project, Filter} and \textsf{Count} and is implemented as follows
\begin{enumerate} \item $\mathbf{\tilde{T}}_1$=\textsf{Project}($\mathbf{\tilde{T}}$, $A$) \item $\mathbf{B}$ =  current indicator bit vector \item  for $i = 1:s_A $ \\Intialize bit vector to $\mathbf{B}$  \\$\phi_i= (A==v_{i,A}) $ \\$\hat{\mathbf{T_2}}$ = \textsf{Filter}($\mathbf{\tilde{T}}_1, \phi_i$)\\ $\mathbf{C}[i]$ = \textsf{Count}($\hat{\mathbf{T_2}}$) \\ end for \item Output $\mathbf{C}$
\end{enumerate}
\item \textsf{GroupBy}($\mathbf{\tilde{T}},A$)- The initial part of the  \textsf{GroupBy} transformation is the exact same as that  for \textsf{GroupBy*} and goes as follows   \begin{enumerate}\item $\mathbf{V}$=\textsf{GroupBy*}$(\boldsymbol{\tilde{\mathcal{D}}},A)$ \\Note that since each entry of $\mathbf{V}$ is a count of records, its value ranges from $\{0,...,m\}$. \item \textsf{AS} creates a mask vector $M$ drawn uniformly at random from $[m]^{s_A}$, i.e.,  \begin{gather*} M[i] \in_R [m], i \in [|V|]\end{gather*} \item \textsf{AS} masks the encrypted true count vector $\mathbf{V}$ for attribute $A$ as follows \begin{gather*}\boldsymbol{\mathcal{V}}[i]= \mathbf{V}[i] \oplus labEnc_{pk}(M[i])\end{gather*} and sends $\boldsymbol{\mathcal{V}}$ to \textsf{CSP}.\item \textsf{CSP} decrypts $\boldsymbol{\mathcal{V}}$, converts each entry to its corresponding one-hot-coding and encrypts it. \begin{gather*}\mathcal{V}[i]=labDec_{sk}(\boldsymbol{\mathcal{V}})\\\tilde{\mathcal{V}[i]}=\mathcal{E}(\mathcal{V}[i])[\text{Generates one-hot-coding  }]\\\boldsymbol{\tilde{\mathcal{V}}}[i]=labEnc_{pk}(\tilde{\mathcal{V}[i]})\end{gather*}\item Notice that each entry of $\boldsymbol{\tilde{\mathcal{V}}}$ is a $m$ -lengthed one-hot-coding vector. \textsf{AS} now simply rotates every entry by its corresponding mask value to obtain the desired  encrypted one-hot-coding $\boldsymbol{\tilde{V}}[i]$. \begin{gather*}\boldsymbol{\tilde{V}}[i]=RightRotate(\boldsymbol{\tilde{\mathcal{V}}},M[i])\end{gather*}  \end{enumerate} Note that the \textsf{GroupBy} primitive could have an alternative implementation using a Yao's garbled circuit that takes an input the encrypted vector and outputs the corresponding one-hot-coding representation. However this would require the circuit to decrypt and re-encrypt $O(m)$ data inside it which would be computationally heavy for larger values of $m$.
\item \textsf{CountDistinct}($\mathbf{V},\epsilon$) - The \textsf{CountDistinct} primitive is implemented as follows \begin{enumerate}\item Firstly the \textsf{AS} creates a mask vector drawn uniformly at random from $[m]^{s_A}$, i.e.,  \begin{gather*} M[i] \in_R [m], i \in [|V|]\end{gather*} \item \textsf{AS} masks the encrypted true count vector $\mathbf{V}$  as follows \begin{gather*}\boldsymbol{\mathcal{V}}[i]= \mathbf{V}[i] \oplus labEnc_{pk}(M[i])\end{gather*} and sends it to the \textsf{CSP} \item \textsf{CSP} decrypts the masked encrypted vector as \begin{gather*}\mathcal{V}[i]=labDec_{sk}(\mathbf{V}[i]), i \in [|V|]\end{gather*} \item Next the \textsf{CSP} generates the following garbled circuit that\begin{enumerate}  \item takes the mask $M$ as an input from the \textsf{AS} \item takes a random number $r$  as an input from the \textsf{CSP}\item takes the decrypted masked vector $\mathcal{V}$ as an input from the \textsf{CSP} \item removes the mask $M$ from $\mathcal{V}$ as \begin{gather*}V[i]=\mathcal{V}[i]-M[i], i \in [|V|]\end{gather*}\item  counts the number of non-zero entries of $V$ as C \item adds the laplace noises \begin{gather*}\mathcal{C}=C+r\end{gather*} and returns $\mathcal{C}$ \end{enumerate} \item The \textsf{AS} evaluates the above circuit and gets output $\mathcal{C}$ \item The \textsf{AS} gets $labEnc_{pk}(r)$ from the \textsf{CSP} and generates $labEnc_{pk}(\mathcal{C})$ to compute\begin{gather*}\mathbf{C}=labEnc_{pk}(\mathcal{C})-labEnc_{pk}(r)\end{gather*} \end{enumerate} \item \textsf{Laplace}($\mathbf{V},\epsilon$)- Recall that both \textsf{AS} and \textsf{CSP} have to add Laplace noise to the output in Crypt$\epsilon$. Hence the \textsf{Laplace} primitive has two components. The first component is executed by the \textsf{AS} wherein,
\begin{enumerate} \item \textsf{AS} generates a noisy vector $\eta$ such that $\eta \in [Lap(\frac{1}{\epsilon})]^{|V|}$ \item encrypts $\eta$ and adds it to the input vector as \begin{gather*}\boldsymbol{\eta}=labEnc_{pk}(\eta)\\\mathbf{\hat{V}}[i]=\mathbf{V}[i]\oplus \boldsymbol{\eta}[i], i \in [|V|]\end{gather*} \end{enumerate} This encrypted noisy vector $\mathbf{\hat{V}}$ is the input for the second phase of the \textsf{Laplace} primitive which is executed by the \textsf{CSP} as follows \begin{enumerate}\item Decrypts $\mathbf{\hat{V}}$ \begin{gather*}\hat{V}=labDec_{sk}(\mathbf{\hat{V}})\end{gather*}  \item Generates a noisy vector $\eta'$ such that $\eta' \in [Lap(\frac{1}{\epsilon})]^{|\hat{V}|}$ \item Finally adds the noise $\eta'$ to $\hat{V}$ \begin{gather*}\hat{\mathcal{V}}[i]=\hat{V}[i]+\eta'[i], i \in [|\hat{V}|]\end{gather*} \item Returns $\hat{\mathcal{V}}$ to \textsf{AS} \end{enumerate}
% Note that in the Crypt$\epsilon$ implementation we need to add two instances of the Laplace noise as opposed to a single instance in the standard central differential privacy setting. After the addition of the first instance of the laplace noise, $\eta$ (by the AS),  the encrypted answer is sent to the CSP. becuse of CSP has only a differential private view Hence the addition of the second instance of the laplace noise can be looked upon as a post-processing step  However and differential privacy is immune to post processing
\item \textsf{NoisyMax}($\mathbf{V},\epsilon,k$)- The input to the NoisyMax primitive is an encrypted vector $\mathbf{V}$ where each entry $V[i]$ is a count. The primitive is implemented via the following steps.  \begin{enumerate}
\item First the \textsf{AS} adds noise to the input encrypted vector as follows \begin{gather*} \eta \in [Lap(\frac{1}{\epsilon})]^{|V|}\\\boldsymbol{\eta}=labEnc_{pk}(\eta)\\\mathbf{\hat{{V}}}[i]=\mathbf{V}[i]+ \boldsymbol{\eta}[i], i \in [|V|] \end{gather*} \item Next the \textsf{AS} creates a mask vector $M$ drawn uniformly at random from $[m]^{s_A}$, i.e.,  \begin{gather*} M[i] \in_R [m], i \in [|V|]\end{gather*} \item \textsf{AS} masks the encrypted noisy vector $\mathbf{\hat{V}}$  as follows \begin{gather*}\boldsymbol{\mathcal{V}}[i]= \mathbf{\hat{V}}[i] \oplus labEnc_{pk}(M[i]), i \in [|V|]\end{gather*} and sends it to the \textsf{CSP} \item \textsf{CSP} decrypts the masked encrypted noisy vector as \begin{gather*}\mathcal{V}[i]=labDec_{sk}(\mathbf{\hat{V}}[i]), i \in [|V|]\end{gather*} \item Next, the following garbled circuit is evaluated which
    \begin{enumerate}[label=\roman*]\item takes noisy masked  vector $\mathcal{V}$ as an input from the \textsf{CSP} \item takes mask $M$ as the input from \textsf{AS}  \item removes the mask from  $\mathcal{V}$  as \begin{gather*} \hat{V}[i]=\mathcal{V}[i]-M[i], i \in [|V|]\end{gather*}  \item computes the top $k$ element over  $\hat{V}$ and returns $arg_{\textit{top k}}\max{\hat{V}[i])}$
    \end{enumerate}
    \end{enumerate}
    \end{enumerate}
    \begin{comment}
\subsection{Query Answering}
In this section, we will show how can we use the aforementioned primitives to answer an arbitrary counting query. Consider a query $q$ given by $q(\mathcal{D})=\sum_{i=1}^k c_i\phi_i(\mathcal{D})$. Let $Attribute(\phi)$ denote the set of all attributes in $\mathcal{A}$ that appear in the boolean condition $\phi$. For e.g., if $\phi = \big((\mathcal{A}_1==v_1) \land \mathcal{A}_2==v_2) \vee \mathcal{A}_3==v_3 \big)$, then  we have $Attribute(\phi)=\{\mathcal{A}_1, \mathcal{A}_2,\mathcal{A}_3\}$.\begin{enumerate}\item Firstly, The AS finds the attribute set of all the boolean conditions $\phi_i, i \in [k]$, i.e., it computes $A^* =\bigcup_{i=1}^k Attribute(\phi_i)$.
\item Next the AS performs a project transformation on inputs attribute set $A^*$ and the entire encrypted database $\boldsymbol{\tilde{\mathcal{D}}}$.
\item Let $A^*= \{A^*_1,A^*_2,\ldots,A^*_t\}, t \leq k$. Next the AS constructs the encrypted one-hot-coding over the entire $t$-dimension 'attribute' $\mathcal{A}^*=\prod_{i=1}^t A^*_i$ by $(t-1)$ iterative application of the cross product transformation.
\item Note that the result of the preceding step is a $m\times 1$ table where the $i^{th} , i \in [m]$ record corresponds to the encrypted one-hot-coding over the entire $t$-dimension domain space of $\mathcal{A}^*$ of data owner $DO_i$. The AS computes the vector $\mathbf{\hat{C}}$ (an input to the filter transformation, sec 1.1) as follows. Clearly length of $\mathbf{\hat{C}}$ is $s^*=\prod_{i=1}^ts^*_i$ where $s^*_i=|dom(A^*_i)|$ and it is initialized to be encrypted zero-vector. For each boolean condition $\phi_i, i \in [k]$, the AS fills in all such entries  $\mathbf{\hat{C}}[j]=Enc_{pk}(c_i), j \in [s^*]$ such that $v_j$ satisfies $\phi_i$ where $v_j \in dom(\mathcal{A}^*) $.
\item This is followed by performing the count transformation by the AS to obtain the encrypted count $\boldsymbol{Ct}$.
\item Next, the AS and the CSP jointly compute the appropriate laplace noise, $\boldsymbol{\eta}$ via the LaplaceMechanism primitive and adds it to $\boldsymbol{Ct}$ to obtain $\boldsymbol{\bar{Ct}}=\boldsymbol{Ct}+\boldsymbol{\eta}$. Note that the sensitivity of the query $q$ is $ \Delta_q=\max\{c_i\}$.
\item Finally CSP decrypts $\boldsymbol{\bar{Ct}}$ to reveal the plaintext noisy count.
\end{enumerate}


\begin{comment}\begin{exmp}
\textit{Query 1:} Count the number of records satisfying $(Age=50 \wedge Gender=Male)\vee Salary=500K$\\
\textit{Crypt$\epsilon$ Program:}
Let $\phi=(Age=50 \wedge Gender=Male)\vee Salary=500K$ and let $\mathcal{I}(\phi)$ denote the set of indices in the one-hot-encoding of  the 3-dimensional attribute $ A'=Age \times Gender \times Salary$ that satisfies $\phi$.
\begin{enumerate}\item $\mathbf{\tilde{T}}_1$=AS.Project($\boldsymbol{\tilde{\mathcal{D}}}$, $Age, Gender, Salary $)  \item  $\mathbf{\tilde{T}}_2$ = AS.CrossProduct($\mathbf{\tilde{T}}_1$, Age, Gender)\item $\mathbf{\tilde{T}}_3$ = AS.CrossProduct($\mathbf{\tilde{T}}_2$, Age $\times$ Gender, Salary)\item  $ \textit{for } i \in [s_{A'}]$\\$\mathbf{C}[i]=
  \begin{cases}
   labEnc_{pk}(1),  & \text{if } i \in \mathcal{I}(\phi)  \\
   labEnc_{pk}(0)      & \text{otherwise }
  \end{cases}$
  \item $\tilde{\mathbf{T}}_4=AS.Filter(\tilde{\mathbf{T}}_3, \mathbf{C})$\item $\mathbf{Ct}=AS.Count(\tilde{\mathbf{T}}_4)$\item $\bar{\mathbf{Ct}}=AS-CSP.LaplaceMechanism(1,\epsilon) \oplus \mathbf{Ct}$\item$ \bar{Ct}=CSP.Dec_{sk}(\tilde{\mathbf{Ct}})$\item Return $\bar{Ct}$\end{enumerate}
\end{exmp}
\begin{exmp}
\textit{Query 2 :} Sum of the salaries of all the departments who have more than 50 employees group by department. \\
\textit{Crypt$\epsilon$ Program:}
\arc{Need to do}
\end{exmp}
\begin{exmp}
\textit{Query 3:} Partition the age in ranges of 10 bins.  Design a $\epsilon$-differentially private mechanism to report the age-bracket with the maximum count. \\
\textit{Crypt$\epsilon$ Program:}
\begin{enumerate}\item $\boldsymbol{\tilde{T}}_1$=AS.Project($\boldsymbol{\tilde{\mathcal{D}}}$, $Age$) \item for i = 1:10\\ $\mathbf{\hat{C}}[j]= \begin{cases}
   labEnc_{pk}(1),  & \text{if } j \in [(i-1)\cdot 10,i\cdot 10-1] \\
   labEnc_{pk}(0)      & \text{otherwise }
  \end{cases}$\\$\thinspace \thinspace \thinspace \thinspace \thinspace\thinspace\thinspace\thinspace\thinspace\thinspace\thinspace\thinspace\thinspace\boldsymbol{\tilde{T}}_2[i]$=AS.Filter$(\boldsymbol{\tilde{T}}_1$, $\mathbf{\hat{C}})$ \\ end for \item for i=1:100\\$\mathbf{V}[i]=$AS.Count($\boldsymbol{\tilde{T}}_2[i]$)\\end for \item M=AS-CSP.NoisyMax$(\mathbf{V})$\item Return M\end{enumerate}
\end{exmp}

\end{comment}
