
\section{Background}
In this section we give a brief introduction to differential privacy and the cryptographic primitives used in \system. 

\subsection{Differential Privacy}
\begin{definition} An algorithm $\mu$
satisfies $\epsilon$-differential privacy ($\epsilon$-DP), where $\epsilon \geq 0$ is a privacy parameter, iff
 for any two datasets $D$ and $D'$ that differ in a single record, we have
\begin{gather}
\forall t \in Range(\mu), Pr \big[\mu(D) = t\big] \leq e^{\epsilon}Pr\big[\mu(D') = t\big]
\end{gather}
where $Range(\mu)$ denotes the set of all possible outputs
of the algorithm $\mu$.
\end{definition} 
The differential privacy guarantee  when
invoked multiple times can
be bounded with sequential composition (section A).

\subsection{Cryptographic Primitives}
\stitle{Linearly Homomorphic Encryption (\textsf{LHE}).}
Let $(\mathcal{M}, +)$ be a finite group. A \textsf{LHE} scheme
for messages in $\mathcal{M}$ is defined  by three algorithms \\
$\bullet$ \textbf{Key Generation }($Gen$) -The key generation algorithm $Gen$ takes the security parameter $\kappa$ as input and outputs
a pair of secret and public keys, $(s_k, p_k) \leftarrow Gen(\kappa)$.\\
$\bullet$ \textbf{Encryption} ($Enc$) - This is a randomized algorithm that encrypts a message $m \in \mathcal{M}$ via the public key $p_k$, to generate ciphertext $\mathbf{c} \leftarrow Enc_{pk}(m)$.\\
$\bullet$\textbf{Decryption} ($Dec$) - The decryption algorithm $Dec$ is a deterministic function that uses the secret key $s_k$ to
recover the original plaintext $m$ from ciphertext $\mathbf{c}$.
\\
In addition, linearly homomorphic encryption scheme supports the two operations $\oplus$ and $cMult$ with the following properties:
\\$\bullet$ \textbf{Operator} $\oplus$ - Let $c_1 \leftarrow Enc_{pk}(m1), \ldots, c_a \leftarrow Enc_{pk}(m_a), a \in \mathcal{Z}_{>0}$. Then we have  $Dec_{sk}(c_1\oplus c_2 ...\oplus c_a)=    m_1 + \ldots   + m_a$  \\
$\bullet$ \textbf{Operator} $cMult(a,c)$ - Let $c\leftarrow  Enc_{sk}(m)$. Then  \\ $Dec_{sk}\big(cMult(a,c)\big)=a\cdot m$ where $cMult(a,c)=c\oplus \ldots \oplus c$ (a times) 


\stitle{Labeled Homomorphic Encryption(\textsf{labHE}).}
Let $(Gen,Enc,Dec)$ be an \textsf{LHE} scheme with security parameter $\kappa$ and message space $\mathcal{M}$. Assume that a multiplication operation is given in $\mathcal{M}$, i.e., is a finite ring. Let also $\mathcal{F}:\{0,1\}^s \times \mathcal{L}\rightarrow \mathcal{M}$ be a pseudo-random function with speed space $\{0,1\}^s$( s= poly($\kappa $)) and the label space $\mathcal{L}$. Define
\\
 $\bullet \textbf{labGen}(\kappa)$ - On input $\kappa$, it runs $Gen(\kappa)$ and outputs $(sk,pk)$
\\$\bullet \textbf{localGen}(pk)$ -  For each user $i$ and with the public key as input, it samples a random seed $\sigma_i \in \{0,1\}^s$ and computes $pk_i = Enc_{pk}(\ddot{\sigma_i})$ where $\ddot{\sigma_i}$ is an  encoding of $\sigma_i$ as an  element of $\mathcal{M}$. It outputs $(\sigma_i,pk_i)$.\\
$\bullet \textbf{labEnc}_{pk}(\sigma_i, m , \tau)$: On input a message $m \in \mathcal{M} $ with label $\tau \in \mathcal{L}$  from user $i$, it computes $b=\mathcal{F}(\sigma_i, \tau))$ and outputs the labeled ciphertext $\mathbf{c}=(a,c) \in \mathcal{M} \times \mathcal{C}$ with $ a= m- b$ in $\mathcal{M}$ and $c=Enc_{pk}(b)$.\\
$\bullet \textbf{labDec}_{sk}(\mathbf{c})$ - This functions inputs a cipher $\mathbf{c}=(a,c) \in \mathcal{M} \times \mathcal{C}$ encrypted under the labHE scheme and decrypts it as $m=a-Dec_{sk}(c)$.
\\
In addition to the aforementioned operations supported by a \textsf{LHE}  scheme, \textsf{labHE} supports multiplication of two labeled ciphers as follows.
\\ $\bullet \textbf{labMult}(\mathbf{c}_1,\mathbf{c}_2)$ -
On input two labeled ciphers $\mathbf{c}_1=(a_1,c_1)$ and $\mathbf{c}_2=(a_2,c_2)$, it computes a "multiplication" ciphertext $\mathbf{d}=labMult(\mathbf{c_1,c_2})=Enc_{pk}(a_1,a_2)\odot cMult(c_1,a_2) \odot cMult(c_2,a_1)$. Observe that $Dec_{sk}(\mathbf{d})=m_1\cdot m_2 -b_1 \cdot b_2$.\\
 $\bullet \textbf{labMultDec}_{sk}(c_1,c_2,\mathbf{d})$ - On input two labels $c_1,c_2$ of two labHE ciphers $\mathbf{c_1},\mathbf{c_2}$ and the output $\mathbf{d}$ of $labMult(\mathbf{c_1},\mathbf{c_2})$, it decrypts the product as $m_3=Dec_{sk}(\mathbf{d})+Dec_{sk}(c_1)\cdot Dec_{sk}(c_2) = m_1\cdot m_2$ .   \\
In this paper we propose an efficient way of extending the $labMult$ operation for a $n$-way multiplication in section \ref{implementation}.


\stitle{Secure Computation.}
%\arc{Not final:placeholder}
Garbled circuit, also known as Yao's protocol \cite{Yao,yao2},  is a generic method for secure  computation that allows two-party evaluation of a function $f(x_1,x_2)$ in the presence of semi-honest adversaries. The protocol is run between two data owners with respective private inputs $x_1$ and $x_2$ such that at the end, no party learns more  
than what is revealed from the output value $f(x_1,x_2)$.  \eat{In the protocol, one of the parties called
generator, builds a "garbled" version of a circuit computing $f$ and sends it over to the second party, called evaluator, alongside the garbled input values 
corresponding to $x_1$.  Upon receiving the circuit, the evaluator 
engages in an oblivious transfer protocol with the generator to obliviously obtain the garbled input for $x_2$. Finally the evaluator can securely compute the  output $f(x_1, x_2)$ from the garbled circuit and the corresponding garbled inputs for $\{x_1,x_2\}$.}

